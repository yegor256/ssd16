% SPDX-FileCopyrightText: Copyright (c) 2021 Yegor Bugayenko
% SPDX-License-Identifier: MIT

\documentclass{article}
\usepackage{../ssd}
\newcommand*\thetitle{Test-Driven}
\newcommand*\thesubtitle{Development}
\begin{document}

\lnTitlePage{13}{16}{8qfd93SyXpM}

\pptToc

\plush{\pptChapter[Psychology]{The Psychology of Testing}}

\plush{\pptQuote{../faces/glenford-myers}{One of the primary causes of poor application testing is the fact that most programmers begin with a \ul{false definition} of the term. They might say: 'Testing is the process of demonstrating that errors \ul{are not present}.'}{\nospell{Glenford J. Myers}, \emph{The Art of Software Testing}}}

\plush{\pptQuote{../bibliography/book-covers/myers}{Don't test a program to show that it works; rather, start with the assumption that the program contains errors. Testing is the process of executing a program with the intent of finding errors.}{\emph{The Art of Software Testing}, \nospell{Glenford J. Myers} et al.}}

\plush[3]{\footnotesize
  \begin{multicols}{2}
  {``If something is to be delivered, then it is the testers who make the final
  \ul{decision} as to whether or not that something is delivered into
  the live environment.''
  ---\scriptsize
  \textcolor{red}{\nospell{Nick Sewell}},
  \emph{How to Test a System That Is Never Finished}, 2009}
  \par
  {``Testing is an essential activity in software engineering.
  In the simplest terms, it amounts to observing the execution
  of a software system to validate whether it behaves
  \ul{as intended}~\ldots''
  ---\scriptsize
  \textcolor{red}{\nospell{Antonia Bertolino}},
  \emph{Software testing research: Achievements, challenges, dreams}, 2007}
  \par\columnbreak
  {``Software testing is the process of executing a software system to determine
  whether it matches its specification and executes in its intended environment.''
  ---\scriptsize
  \textcolor{red}{\nospell{James~A. Whittaker}},
  \emph{What Is Software Testing? And Why Is It So Hard?}, 2000}
  \par
  {``We distinguish the four major testing models...
  One model says we test to demonstrate that some
  version of the software satisfies its specification, two models say
  we test to detect faults, and the fourth says we test to prevent faults.
  These three goals need not conflict and, in fact, are all present in the
  prevention model.''
  ---\scriptsize
  \textcolor{red}{\nospell{David Gelperin}},
  \emph{The growth of software testing}, 1988}
  \end{multicols}
}

\plush{\pptQuote{../bibliography/book-covers/pragmatic-testing}{Software testing is not about proving conclusively that the software is free from any defects, or even about discovering \ul{all} the defects. Such a mission for a test team is truly \ul{impossible} to achieve.}{\nospell{Rex Black}, \emph{Pragmatic Software Testing: Becoming Effective and Efficient Test Professional}}}

\plush{\pptQuote{../bibliography/book-covers/testing-chauhan}{The immediate goal of testing is to find errors at any stage of software development. \ul{More} the bugs discovered at an early stage, \ul{better} will be the success rate of software testing.}{\nospell{Naresh Chauhan}, \emph{Software Testing: Principles and Practices}}}

\plush{\pptQuote{../bibliography/book-covers/beizer1995}{Anything written by people has bugs. Not testing something is equivalent to asserting that it's bug-free. Programmers can't think of everything especially of all the possible interactions between features and between different pieces of software. We try to \ul{break} software because that's \ul{the only} practical way we know of to be confident about the product's fitness for use.}{\nospell{Boris Beizer}, \emph{Black-Box Testing: Techniques for Functional Testing of Software and Systems}}}

\plush[2]{\pptQuote{../bibliography/book-covers/beizer-testing}{The probability of showing that the software works decreases as testing increases; that is, the more you test, the likelier you are to find a bug. Therefore, if your objective is to demonstrate a high probability of working, that objective is best achieved by not testing at all!}{\nospell{Beizer, Boris}, \emph{Software Testing Techniques}}}

\plush[2]{\pptQuote{../faces/edsger-dijkstra}{Program testing can be used to show the presence of bugs, but never to show their absence!}{\nospell{Edsger W. Dijkstra}, \emph{Notes on Structured Programming}, 1970}}

\plush[3]{%
  \small\begin{multicols}{2}
  \emph{Software Testing Philosophy}\\
  Bee Mobile Meetup\\
  Moscow, Russia, 7 November 2018\\
  \pptQR[1in]{https://youtu.be/y0X-WQ1bOUI}\par
  \emph{Testing and Testers}\\
  TestCon \\
  Moscow, Russia, 16 September 2020\\
  \pptQR[1in]{https://www.youtube.com/watch?v=aYXuK2do6FA}
  \par\columnbreak
  \emph{Software Testing Pitfalls}\\
  JPoint \\
  Moscow, Russia, 5 April 2019\\
  \pptQR[1in]{https://www.youtube.com/watch?v=9ynzUGZjKFk}\par
  \emph{Quality Assurance vs. Testing}\\
  QA Fest\\
  Kyiv, Ukraine, 20 September 2019\\
  \pptQR[1in]{https://www.youtube.com/watch?v=jZitXMQaXvE}
  \end{multicols}}

\plush[2]{\pptChapter[TDD]{Test Driven Development (TDD)}}

\clearpage\begin{multicols}{2}
\begin{ffcode}
(test one
  (is (= 1 (f 1))))
(test two
  (is (= 1 (f 2))))
(test fifteen
  (is (= 610 (f 15))))
\end{ffcode}
\par\columnbreak
Can you put some code here?
\end{multicols}\clearpage

\clearpage\begin{multicols}{2}
\begin{ffcode}
(test one
  (is (= 1 (f 1))))
(test two
  (is (= 1 (f 2))))
(test fifteen
  (is (= 610 (f 15))))
\end{ffcode}
\par\columnbreak
\begin{ffcode}
(defun f (n)
  (cond
    ((= n 1) 0)
    ((= n 2) 1)
    (+
      (f (- n 1))
      (f (- n 2)))))
\end{ffcode}
\end{multicols}\clearpage

\plush[6]{\pptQuote{../faces/dhh}{Test-first fundamentalism is like abstinence-only sex ed: An unrealistic, ineffective morality campaign for self-loathing and shaming.}{\nospell{David Heinemeier Hansson}, \emph{\href{https://dhh.dk/2014/tdd-is-dead-long-live-testing.html}{TDD is dead. Long live testing}}}}

\plush[2]{\pptQuote{../faces/robert-martin}{It would not surprise me if, one day, TDD had the \ul{force of law} behind it.}{Robert Martin, \emph{\href{https://blog.cleancoder.com/uncle-bob/2014/05/02/ProfessionalismAndTDD.html}{Professionalism and TDD (Reprise)}}}}

\plush[5]{
  \pptPic{0.7}{flow}\\
  ``I only create tests later when my users express the need for them by reporting bugs.''\\
  \url{https://www.yegor256.com/2017/03/24/tdd-that-works.html}
}

\plush[5]{
  \pptPic{0.8}{curve}\\
  `` I don’t need tests at the beginning of the project''\\
  \url{https://www.yegor256.com/2017/03/24/tdd-that-works.html}
}

\plush[4]{
  \pptHeader{Safety Net}
  \pptPic{0.8}{safety-net}
}

\plush{\pptChapter[Unit]{Unit vs. Integration Tests}}

\print{\pptPinQR{https://www.kenneth-truyers.net/2012/12/15/key-qualities-of-a-good-unit-test/}}
\print{\pptHeader{Good Tests Are:}}
\plick[2]{1) \textbf{Short}: less than $x$ lines each}
\plick[2]{2) \textbf{Fast}: less than $y$ milliseconds each}
\plick[2]{3) \textbf{Independent}: runs alone and in a suite}
\plick[2]{4) \textbf{Portable}: runs on your laptop and on mine}
\plick[2]{5) \textbf{Careful}: side effect free, doesn't leave temp files}
\plush[2]{6) \textbf{Isolated}: doesn't touch my files}

\clearpage\begin{pptWide}{2}\small
\begin{ffcode}
import java.nio.file.Files;
class Book {
  String title() {
    return Files.readAllLines(
      Paths.get("/my-data/book.txt")
    )[0];
  }
}
\end{ffcode}
\par\columnbreak
\begin{ffcode}
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
class BookTest {
  @Test
  void canRetrieveTitle() {
    String t = new Book().title();
    Assertions.assertEquals(
      "Object Thinking", t
    );
  }
}
\end{ffcode}
\end{pptWide}
Is it Short, Fast, Independent, Portable, Careful, and Isolated?
\clearpage

\clearpage\begin{pptWide}{2}\small
\begin{ffcode}
import java.nio.file.Files;
class Book {
  private Path file;
  Book(Path f) {
    this.file = f;
  }
  String title() {
    return Files.readAllLines(
      this.file
    )[0];
  }
}
\end{ffcode}
\par\columnbreak
\begin{ffcode}
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
class BookTest {
  @Test
  void canRetrieveTitle() {
    Path f = Paths.get("/tmp/temp.txt");
    String title = "Object Thinking";
    Files.write(f, title.getBytes());
    String t = new Book().title();
    Assertions.assertEquals(title, t);
  }
}
\end{ffcode}
\end{pptWide}
Is it Short, Fast, Independent, Portable, Careful, and Isolated?
\clearpage

\clearpage\begin{pptWide}{2}\small
\begin{ffcode}
import java.nio.file.Files;
class Book {
  private Path file;
  Book(Path f) {
    this.file = f;
  }
  String title() {
    return Files.readAllLines(
      this.file
    )[0];
  }
}
\end{ffcode}
\par\columnbreak
\begin{ffcode}
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
class BookTest {
  @Test
  void canRead(@TempDir Path dir) {
    Path f = dir.resolve("temp.txt");
    String title = "Object Thinking";
    Files.write(f, title.getBytes());
    String t = new Book().title();
    Assertions.assertEquals(title, t);
  }
}
\end{ffcode}
\end{pptWide}\clearpage

\plush[10]{\pptChapter[Coverage]{Test Coverage}}

\plush[5]{
  \pptPic{0.8}{coverage}
  \url{https://codecov.io/gh/yegor256/sibit/tree/master/lib}
}

\print{\pptHeader{Coverage Criteria}}
\plick[2]{\textbf{Function} Coverage\br\small Has each function (or subroutine) in the program been called?}
\plick[2]{\textbf{Statement} Coverage\br\small Has each statement in the program been executed?}
\plick[2]{\textbf{Edge} Coverage\br\small Has every edge in the control-flow graph been executed?}
\plick[2]{\textbf{Branch} Coverage\br\small Has each branch of each control structure been executed?}
\plush[2]{\textbf{Condition} Coverage\br\small Has each Boolean sub-expression evaluated both to true and false?}

\clearpage
\pptHeader{Mutation Testing + Coverage}
\begin{pptWide}{2}\small
\begin{ffcode}
def f(n)
  n * n + 1
end
\end{ffcode}
\par\columnbreak
\begin{ffcode}
f(0) == 1
f(1) == 2
f(2) == 5
\end{ffcode}
\end{pptWide}\clearpage

\clearpage
\pptHeader{Mutation Testing + Coverage}
\begin{pptWide}{2}\small
\begin{ffcode}
def f(n)
  n * n + 1
end

# Mutant no. 1
def f(n)
  n + n + 1
end

# Mutant no. 2
def f(n)
  n * n - 1
end
\end{ffcode}
\par\columnbreak
\begin{ffcode}
f(0) == 1
f(1) == 2
f(2) == 5
\end{ffcode}

Test coverage: 100\% \par
Mutation coverage = 50\%
\end{pptWide}\clearpage

\plush{\pptChapter[Performance]{Automated Performance Testing}}

\plush[5]{
  \pptHeader{Some Tools}
  \begin{multicols}{2}
  \nospell{
  WebLOAD\br
  LoadNinja\br
  ReadyAPI Performance\br
  LoadView\br
  StormForge\br
  Keysight’s Eggplant\br
  Apache JMeter\br
  LoadRunner\br
  Appvance\br
  NeoLoad\br
  LoadComplete\br
  WAPT\br
  Loadster\br
  k6\br
  Rational Performance Tester\br
  Testing Anywhere\br
  \textbf{\ul{Apache Bench}}
  }
  \end{multicols}
}

\plush{\pptChapter[BDD]{Behavior Driven Development (BDD)}}

\plush[3]{
  \pptPic{0.8}{bdd}
  \url{https://www.agilealliance.org/glossary/bdd}
}

\plush{\pptChapter[QA]{Testing vs. QA}}

\plush[5]{
  \pptBanner{Testing $\not=$ Quality Assurance (QA)}
  \pptPinQR[left]{https://www.youtube.com/watch?v=jZitXMQaXvE}
  \pptPic{0.8}{qa}
}

\plush{\innoBVC}

\plush[2]{%
  \begin{multicols}{2}
    \innoBook{myers2012art}
    \par\columnbreak
    \innoBook{beck2002test}
  \end{multicols}
}

\plush{%
  \pptBanner{Where to publish:}
  International Symposium on Software Testing and Analysis (ISSTA)
}

\plush[3]{%
  \pptBanner{Call to Action:}
  Integrate mutation coverage control into your build.
}

\plush[5]{%
  \pptBanner[orange]{Still unresolved issues:}
  \begin{itemize}
    \item How to \ul{test} performance right?
    \item How to \ul{create} tests automatically?
    \item How to \ul{motivate} programmers write tests?
    \item How to \ul{control} the quality of testing?
  \end{itemize}
}

\end{document}
